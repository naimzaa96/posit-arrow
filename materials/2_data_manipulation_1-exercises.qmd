---
title: "Data Manipulation Part 1 - Exercises"
execute:
  echo: true
  messages: false
  warning: false
---

```{r}
#| label: load-packages
library(arrow)
library(dplyr)
library(stringr)
```

```{r}
#| label: open-dataset
nyc_taxi <- open_dataset(here::here("data/nyc-taxi"))
nyc_taxi
```

::: {#exercise-compute-collect .callout-tip}
# Using `compute()` and `collect()`

::: panel-tabset
## Problem

1.  How many taxi fares in the dataset had a total amount greater than \$100?

2.  How many distinct pickup locations (distinct combinations of the `pickup_latitude` and `pickup_longitude` columns) are in the dataset since 2016? Use `nrow()` to work this out.

## Solution 1

```{r}
#| label: compute-collect-1
#| cache: true
nyc_taxi |>
  filter(total_amount > 100) |>
  nrow()
```

## Solution 2

```{r}
#| label: compute-collect-2
#| cache: true
nyc_taxi |>
  filter(year >= 2016) |>
  distinct(pickup_longitude, pickup_latitude) |>
  compute() |>
  nrow()
```
:::
:::

::: {#exercise-dplyr-api .callout-tip}
# Using the dplyr API in arrow

::: panel-tabset
## Problem

1.  Use the `dplyr::filter()` and `stringr::str_ends()` functions to return a subset of the data which is a) from September 2020, and b) the value in `vendor_name` ends with the letter "S".

2.  Try to use the `stringr` function `str_replace_na()` to replace any `NA` values in the `vendor_name` column with the string "No vendor" instead. What happens, and why?

3.  Bonus question: see if you can find a different way of completing the task in question 2.

## Solution 1

```{r}
#| label: compute-collect-sol1
#| eval: false
nyc_taxi |>
  filter(str_ends(vendor_name, "S"), year == 2020,  month == 9) |>
  collect()
```

## Solution 2 and 3

```{r}
#| label: compute-collect-sol2
#| error: true
#| eval: false
nyc_taxi |>
  mutate(vendor_name = stringr::str_replace_na(vendor_name, "No vendor")) |>
  head() |>
  collect()
```

This won't work as `stringr::str_replace_na()` hasn't been implemented in Arrow. You could try using `mutate()` and `ifelse()` here instead.

```{r}
#| label: compute-collect-sol3
#| eval: false
nyc_taxi |>
  mutate(vendor_name = ifelse(is.na(vendor_name), "No vendor", vendor_name)) |>
  head() |>
  collect()
```

Or, if you only needed a subset of the data, you could apply the function after collecting it into R memory.

```{r}
#| label: compute-collect-sol4
#| eval: false
nyc_taxi |>
  filter(year == 2019, month == 10) |> # smaller subset of the data
  collect() |>
  mutate(vendor_name = stringr::str_replace_na(vendor_name, "No vendor"))
```

Alternatively, if you work with user-defined functions, you can define it yourself:

```{r}
#| label: udf
#| eval: false

# Preview the distinct vendor names before we start
nyc_taxi |>
  filter(year == 2019) |> # smaller subset of the data
  distinct(vendor_name) |>
  collect()

register_scalar_function(
  name = "replace_vendor_na",
  function(context, string) {
    stringr::str_replace_na(string, "No vendor")
  },
  in_type = schema(string = string()),
  out_type = string(),
  auto_convert = TRUE
)

vendor_names_fixed <- nyc_taxi |>
  mutate(vendor_name = replace_vendor_na(vendor_name)) 

# Preview the distinct vendor names to check it's worked
vendor_names_fixed |>
  filter(year == 2019) |> # smaller subset of the data
  distinct(vendor_name) |>
  collect()
```

:::
:::
