{
  "hash": "f4fe5f0b057209ad5d38bec23b079a19",
  "result": {
    "markdown": "---\nfooter: \"[üîó posit.io/arrow](https://posit-conf-2023.github.io/arrow)\"\nlogo: \"images/logo.png\"\nexecute:\n  echo: true\nformat:\n  revealjs: \n    theme: default\nengine: knitr\n---\n\n\n# Data Manipulation---Part 2 {#data-manip-2}\n\n\n::: {.cell}\n\n:::\n\n\n## What if a function binding doesn't exist - revisited!\n\n* Option 1 - find a workaround\n* Option 2 - user-defined functions (UDFs)\n\n## Why use a UDF?\n\nSometimes it's hard to find a workaround\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi |>\n  mutate(duration_minutes = difftime(pickup_datetime, dropoff_datetime, units = \"minutes\")) |>\n  select(pickup_datetime, dropoff_datetime, duration_minutes) |>\n  head() |>\n  collect()\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: In difftime(pickup_datetime, dropoff_datetime, units = \"minutes\"), `difftime()` with units other than `secs` not supported in Arrow\nCall collect() first to pull data into R.\n```\n:::\n:::\n\n\n# User-defined functions (aka UDFs)\n\n-   Define your own functions\n-   Scalar functions only - 1 row input and 1 row output\n\n## User-defined functions - definition\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregister_scalar_function(\n  name = \"time_diff_minutes\",\n  function(context, pickup, dropoff) {\n    difftime(dropoff, pickup, units = \"mins\") |>\n      round() |>\n      as.integer()\n  },\n  in_type = schema(\n    pickup = timestamp(unit = \"ms\"),\n    dropoff = timestamp(unit = \"ms\")\n  ),\n  out_type = int32(),\n  auto_convert = TRUE\n)\n```\n:::\n\n\n## User-defined functions - definition\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2\"}\nregister_scalar_function(\n  name = \"time_diff_minutes\",\n  function(context, pickup, dropoff) {\n    difftime(dropoff, pickup, units = \"mins\") |>\n      round() |>\n      as.integer()\n  },\n  in_type = schema(\n    pickup = timestamp(unit = \"ms\"),\n    dropoff = timestamp(unit = \"ms\")\n  ),\n  out_type = int32(),\n  auto_convert = TRUE\n)\n```\n:::\n\n\n## User-defined functions - definition\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"3,4,5,6,7\"}\nregister_scalar_function(\n  name = \"time_diff_minutes\",\n  function(context, pickup, dropoff) {\n    difftime(dropoff, pickup, units = \"mins\") |>\n      round() |>\n      as.integer()\n  },\n  in_type = schema(\n    pickup = timestamp(unit = \"ms\"),\n    dropoff = timestamp(unit = \"ms\")\n  ),\n  out_type = int32(),\n  auto_convert = TRUE\n)\n```\n:::\n\n\n## User-defined functions - definition\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"8,9,10,11\"}\nregister_scalar_function(\n  name = \"time_diff_minutes\",\n  function(context, pickup, dropoff) {\n    difftime(dropoff, pickup, units = \"mins\") |>\n      round() |>\n      as.integer()\n  },\n  in_type = schema(\n    pickup = timestamp(unit = \"ms\"),\n    dropoff = timestamp(unit = \"ms\")\n  ),\n  out_type = int32(),\n  auto_convert = TRUE\n)\n```\n:::\n\n\n## User-defined functions - definition\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"12\"}\nregister_scalar_function(\n  name = \"time_diff_minutes\",\n  function(context, pickup, dropoff) {\n    difftime(dropoff, pickup, units = \"mins\") |>\n      round() |>\n      as.integer()\n  },\n  in_type = schema(\n    pickup = timestamp(unit = \"ms\"),\n    dropoff = timestamp(unit = \"ms\")\n  ),\n  out_type = int32(),\n  auto_convert = TRUE\n)\n```\n:::\n\n\n## User-defined functions - usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi |>\n  mutate(duration_minutes = time_diff_minutes(pickup_datetime, dropoff_datetime)) |>\n  select(pickup_datetime, dropoff_datetime, duration_minutes) |>\n  head() |>\n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 √ó 3\n  pickup_datetime     dropoff_datetime    duration_minutes\n  <dttm>              <dttm>                         <int>\n1 2012-11-02 23:40:32 2012-11-02 23:58:16               18\n2 2012-11-02 23:40:41 2012-11-02 23:45:56                5\n3 2012-11-02 23:40:50 2012-11-02 23:49:20                8\n4 2012-11-02 23:40:52 2012-11-02 23:46:15                5\n5 2012-11-02 23:41:00 2012-11-02 23:44:00                3\n6 2012-11-02 23:41:00 2012-11-02 23:45:00                4\n```\n:::\n:::\n\n\n## Your Turn\n\n1.  Write a user-defined function which wraps the `stringr` function `str_replace_na()`, and use it to replace any `NA` values in the `vendor_name` column with the string \"No vendor\" instead.\n\n‚û°Ô∏è [Data Manipulation Part I Exercises Page](4_data_manipulation_2-exercises.html)\n\n## Summary\n\n* You can use UDFs to create your own bindings when they don't exist!\n\n# Joins\n\n## Joining a reference table\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvendors <- tibble::tibble(\n  code = c(\"VTS\", \"CMT\", \"DDS\"),\n  full_name = c(\n    \"Verifone Transportation Systems\",\n    \"Creative Mobile Technologies\",\n    \"Digital Dispatch Systems\"\n  )\n)\n\nnyc_taxi |>\n  left_join(vendors, by = c(\"vendor_name\" = \"code\")) |>\n  select(vendor_name, full_name, pickup_datetime) |>\n  head(3) |>\n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 √ó 3\n  vendor_name full_name                       pickup_datetime    \n  <chr>       <chr>                           <dttm>             \n1 VTS         Verifone Transportation Systems 2012-10-07 18:19:00\n2 VTS         Verifone Transportation Systems 2012-10-07 18:19:00\n3 VTS         Verifone Transportation Systems 2012-10-07 18:19:00\n```\n:::\n:::\n\n\n## Traps for the unwary\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi_zones <-\n  read_csv_arrow(here::here(\"data/taxi_zone_lookup.csv\")) |>\n  select(location_id = LocationID,\n         borough = Borough)\n\nnyc_taxi_zones\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 265 √ó 2\n   location_id borough      \n         <int> <chr>        \n 1           1 EWR          \n 2           2 Queens       \n 3           3 Bronx        \n 4           4 Manhattan    \n 5           5 Staten Island\n 6           6 Staten Island\n 7           7 Queens       \n 8           8 Queens       \n 9           9 Queens       \n10          10 Queens       \n# ‚Ñπ 255 more rows\n```\n:::\n:::\n\n\n## Why didn't this work?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi |>\n  left_join(nyc_taxi_zones, by = c(\"pickup_location_id\" = \"location_id\")) |>\n  collect()\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `compute.arrow_dplyr_query()`:\n! Invalid: Incompatible data types for corresponding join field keys: FieldRef.Name(pickup_location_id) of type int64 and FieldRef.Name(location_id) of type int32\n/home/nic/arrow/cpp/src/arrow/acero/hash_join_node.cc:131  ValidateSchemas(join_type, left_schema, left_keys, left_output, right_schema, right_keys, right_output, left_field_name_suffix, right_field_name_suffix)\n/home/nic/arrow/cpp/src/arrow/acero/hash_join_node.cc:724  schema_mgr->Init( join_options.join_type, left_schema, join_options.left_keys, join_options.left_output, right_schema, join_options.right_keys, join_options.right_output, join_options.filter, join_options.output_suffix_for_left, join_options.output_suffix_for_right)\n```\n:::\n:::\n\n\n## Schema for the `nyc_taxi` table\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi$schema\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSchema\nvendor_name: string\npickup_datetime: timestamp[ms]\ndropoff_datetime: timestamp[ms]\npassenger_count: int64\ntrip_distance: double\npickup_longitude: double\npickup_latitude: double\nrate_code: string\nstore_and_fwd: string\ndropoff_longitude: double\ndropoff_latitude: double\npayment_type: string\nfare_amount: double\nextra: double\nmta_tax: double\ntip_amount: double\ntolls_amount: double\ntotal_amount: double\nimprovement_surcharge: double\ncongestion_surcharge: double\npickup_location_id: int64\ndropoff_location_id: int64\nyear: int32\nmonth: int32\n```\n:::\n:::\n\n\n## Schema for the `nyc_taxi_zones` table\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrow_table(nyc_taxi_zones)$schema\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSchema\nlocation_id: int32\nborough: string\n```\n:::\n:::\n\n\n-   `pickup_location_id` is int64 in the `nyc_taxi` table\n-   `location_id` is int32 in the `nyc_taxi_zones` table\n\n## Take control of the schema\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi_zones_arrow <- arrow_table(\n  nyc_taxi_zones, \n  schema = schema(location_id = int64(), borough = utf8())\n)\n```\n:::\n\n\n-   `schema()` takes variable name / types as input\n-   {arrow} has various \"type\" functions: `int64()`, `utf8()`, `boolean()`, `date32()` etc\n\n## Take control of the schema\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi_zones_arrow <- arrow_table(\n  nyc_taxi_zones, \n  schema = schema(location_id = int64(), borough = utf8())\n)\nnyc_taxi_zones_arrow$schema\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSchema\nlocation_id: int64\nborough: string\n```\n:::\n:::\n\n\n## Prepare the auxiliary tables\n\n\n::: {.cell}\n\n```{.r .cell-code}\npickup <- nyc_taxi_zones_arrow |>\n  select(pickup_location_id = location_id,\n         pickup_borough = borough)\n\ndropoff <- nyc_taxi_zones_arrow |>\n  select(dropoff_location_id = location_id,\n         dropoff_borough = borough)\n```\n:::\n\n\n-   Join separately for the pickup and dropoff zones\n\n\n```{=html}\n<!-- \n    * simple example of a join\n    * show a join with unmatched schemas\n    * making the schemas match\n-->\n```\n\n## Join and cross-tabulate\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tictoc)\n\ntic()\nborough_counts <- nyc_taxi |> \n  left_join(pickup) |>\n  left_join(dropoff) |>\n  count(pickup_borough, dropoff_borough) |>\n  arrange(desc(n)) |>\n  collect()\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1255.398 sec elapsed\n```\n:::\n:::\n\n\n<br>\n\n2-3 minutes to join twice and cross-tabulate on non-partition variables, with 1.15 billion rows of data üôÇ\n\n## The results\n\n\n::: {.cell}\n\n```{.r .cell-code}\nborough_counts\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 50 √ó 3\n   pickup_borough dropoff_borough         n\n   <chr>          <chr>               <int>\n 1 <NA>           <NA>            732357953\n 2 Manhattan      Manhattan       351198872\n 3 Queens         Manhattan        14440705\n 4 Manhattan      Queens           13052517\n 5 Manhattan      Brooklyn         11180867\n 6 Queens         Queens            7440356\n 7 Unknown        Unknown           4491811\n 8 Queens         Brooklyn          3662324\n 9 Brooklyn       Brooklyn          3550480\n10 Manhattan      Bronx             2071830\n# ‚Ñπ 40 more rows\n```\n:::\n:::\n\n\n## Your Turn\n\n1.  How many taxi pickups were recorded in 2019 from the three major airports covered by the NYC Taxis data set (JFK, LaGuardia, Newark)?\n\n‚û°Ô∏è [Data Manipulation Part I Exercises Page](4_data_manipulation_2-exercises.html)\n\n## Summary\n\n* You can join arrow tables and datasets to R data frames and arrow tables\n* The arrow data type of join keys must always match\n\n# Window functions\n\n## What are window functions?\n\n-   calculations within groups\n\n## Grouped summaries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfare_by_year <- nyc_taxi |>\n  filter(year %in% 2021:2022) |>\n  select(year, fare_amount)\n\nfare_by_year |>\n  group_by(year) |>\n  summarise(mean_fare = mean(fare_amount)) |> \n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 √ó 2\n   year mean_fare\n  <int>     <dbl>\n1  2021      13.5\n```\n:::\n:::\n\n\n## Window functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfare_by_year |>\n  group_by(year) |>\n  mutate(mean_fare = mean(fare_amount)) |> \n  collect()\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: window functions not currently supported in Arrow\nCall collect() first to pull data into R.\n```\n:::\n:::\n\n\n## Window functions - via joins\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfare_by_year |>\n  left_join(\n    nyc_taxi |>\n      filter(year %in% 2021:2022) |>\n      group_by(year) |>\n      summarise(mean_fare = mean(fare_amount))\n  ) |> \n  arrange(desc(fare_amount)) |>\n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 30,902,618 √ó 3\n    year fare_amount mean_fare\n   <int>       <dbl>     <dbl>\n 1  2021     818283.      13.5\n 2  2021     398466.      13.5\n 3  2021     395854.      13.5\n 4  2021       6965       13.5\n 5  2021       6960.      13.5\n 6  2021       6010       13.5\n 7  2021       5954       13.5\n 8  2021       4969       13.5\n 9  2021       3555.      13.5\n10  2021       3009       13.5\n# ‚Ñπ 30,902,608 more rows\n```\n:::\n:::\n\n\n## Window functions - via duckdb\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfare_by_year |>\n  group_by(year) |>\n  to_duckdb() |>\n  mutate(mean_fare = mean(fare_amount)) |> \n  to_arrow() |>\n  arrange(desc(fare_amount)) |>\n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 30,902,618 √ó 3\n    year fare_amount mean_fare\n   <int>       <dbl>     <dbl>\n 1  2021     818283.      13.5\n 2  2021     398466.      13.5\n 3  2021     395854.      13.5\n 4  2021       6965       13.5\n 5  2021       6960.      13.5\n 6  2021       6010       13.5\n 7  2021       5954       13.5\n 8  2021       4969       13.5\n 9  2021       3555.      13.5\n10  2021       3009       13.5\n# ‚Ñπ 30,902,608 more rows\n```\n:::\n:::\n\n\n## Your Turn\n\n1.  How many trips in September 2019 had a longer than average distance for that month?\n\n‚û°Ô∏è [Data Manipulation Part I Exercises Page](4_data_manipulation_2-exercises.html)\n\n## Summary\n\n* Window functions in arrow can be achieved via joins or passing data to and from duckdb",
    "supporting": [
      "4_data_manipulation_2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}